
type Movie {
    # The ! sets the ID to be a unique identifier
    id: ID!
    # Name of the movie
    title: String
    # Gets all incoming relationships with type 'ACTED_IN'
    actors: [Person] @relation(name: "ACTED_IN", direction: "IN")
    # Gets the average rating for a given movie with a Cypher statement
    avgRating: Float @cypher( statement: "MATCH (this)<-[r:REVIEWED]-(p:Person) RETURN coalesce(toFloat(avg(r.rating)),0)")
}

type Person {
    id: ID!
    name: String
}

# Specify a custom Cypher query in GraphQL using this construct.
type Query {
    peopleBySubstring(substring: String): [Person] @cypher( statement: "MATCH (u:Person) WHERE u.name CONTAINS $substring RETURN u")
}

type ExecutionInformation {
    name: String
    registrationDate: String
    id: String
    type: String
    message: String
    rwior: String
}

type Execution {
    name: String
    id: String
    type: String
    executionStart: String
    executionEnd: String
    durationMs: String
    success: String @cypher(statement: "MATCH (this) WITH CASE this.result WHEN True THEN '✔️' ELSE '❌' END  as result RETURN result")
    file: String @cypher( statement: "MATCH (this)-[r:EXECUTION_OF_JOB]-(j:Job) RETURN j.filename")
    RWIOR: String @cypher( statement: "MATCH (this) RETURN this.linesRead + '/' + this.linesWritten + '/' + this.linesInput + '/' + this.linesOutput + '/' + this.linesRejected")
    loggingText: String  @cypher( statement: "MATCH (this) RETURN coalesce(this.loggingText, 'No logs found.')")
    subexecutions: [ExecutionInformation] @cypher (statement: """MATCH (this)-[:EXECUTES*]->(e2)
WITH {name: e2.name,
    registrationDate: e2.registrationDate,
    id: e2.id,
    type: e2.type,
    message: coalesce(e2.comment, e2.status),
        rwior: e2.linesRead + '/' + e2.linesWritten + '/' + e2.linesInput + '/' + e2.linesOutput + '/' + e2.linesRejected } as tuple
        WITH tuple ORDER BY tuple.registrationDate
        RETURN tuple""")
}

#MATCH (e:Execution)-[:EXECUTION_OF_JOB]->(j:Job)
#RETURN j.name as job, j.filename as jobfile, e.name as execution, e.id as executionId, e.executionStart as start
#ORDER BY start DESC

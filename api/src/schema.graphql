
type ExecutionInformation {
    name: String
    registrationDate: String
    id: String
    type: String
    message: String
    rwior: String
}

type ErrorInformation {
    name: String
    id: String
    errors: String
    loggingText: String
}

type Execution {
    name: String
    id: String
    type: String
    errors: String
    executionStart: String
    executionEnd: String
    nrResultRows: String
    nrResultFiles: String
    duration: String @cypher( statement: "MATCH (this) RETURN this.durationMs")
    success: String @cypher(statement: "MATCH (this) WITH CASE this.result WHEN True THEN '✔️' ELSE '❌' END  as result RETURN result")
    file: String @cypher( statement: "MATCH (this)-[r:EXECUTION_OF_JOB]-(j:Job) RETURN j.filename")
    RWIOR: String @cypher( statement: "MATCH (this) RETURN this.linesRead + '/' + this.linesWritten + '/' + this.linesInput + '/' + this.linesOutput + '/' + this.linesRejected")
    loggingText: String  @cypher( statement: "MATCH (this) RETURN coalesce(this.loggingText, 'No logs found.')")
    subexecutions: [ExecutionInformation] @cypher (statement:
        """MATCH (this)-[:EXECUTES*]->(e2)
        WITH {name: e2.name,
        registrationDate: e2.registrationDate,
        id: e2.id,
        type: e2.type,
        message: coalesce(e2.comment, e2.status),
        rwior: e2.linesRead + '/' + e2.linesWritten + '/' + e2.linesInput + '/' + e2.linesOutput + '/' + e2.linesRejected } as tuple
        WITH tuple ORDER BY tuple.registrationDate
        RETURN tuple""")
    rooterrors: [ErrorInformation] @cypher (statement:
        """
        MATCH (this)-[:EXECUTES*]->(e:Execution) WHERE e.errors <> 0 AND NOT EXISTS ((e)-[:EXECUTES]->())
        RETURN {id: e.id, name: e.name, errors: e.errors,loggingText: e.loggingText}
        """)
}

